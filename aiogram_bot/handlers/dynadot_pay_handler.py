import os
import aiohttp
from aiogram import Router, F
from aiogram.types import CallbackQuery, Message, InlineKeyboardMarkup, InlineKeyboardButton, FSInputFile
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import StatesGroup, State
from django.db import transaction
from dotenv import load_dotenv

from bot.models import PurchasedDomain

load_dotenv()
API_KEY = os.getenv("API_KEY")

API_URL = "https://api.dynadot.com/api3.json"
UPLOAD_DIR = "uploads"
OUTPUT_FILE = "purchased_domains.txt"

router = Router()


class DomainStates(StatesGroup):
    WaitingForConfirmation = State()
    WaitingForFile = State()
    ProcessingPurchase = State()


# ‚úÖ –ü–æ–∫—É–ø–∫–∞ –¥–æ–º–µ–Ω–æ–≤ —á–µ—Ä–µ–∑ API –∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ –ë–î
async def purchase_domains(domains, session):
    purchased = []
    for i in range(0, len(domains), 99):
        chunk = domains[i:i + 99]
        params = {"key": API_KEY, "command": "bulk_register"}
        params.update({f"domain{idx}": domain for idx, domain in enumerate(chunk)})

        try:
            async with session.get(API_URL, params=params) as response:
                data = await response.json()
                if data.get("ResponseCode") == "0":
                    purchased.extend(chunk)
        except Exception as e:
            print(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–∫—É–ø–∫–µ –¥–æ–º–µ–Ω–æ–≤: {e}")

    # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ –ë–î
    async with transaction.atomic():
        for domain in purchased:
            await PurchasedDomain.objects.acreate(domain=domain)

    return purchased


# üïπÔ∏è –û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞–∂–∞—Ç–∏—è –∫–Ω–æ–ø–∫–∏ "–î–∞" ‚Üí –ü–æ–∫—É–ø–∫–∞ –¥–æ–º–µ–Ω–æ–≤
@router.callback_query(F.data == "yes_dynadot_pay")
async def handle_yes_dynadot_pay(callback_query: CallbackQuery, state: FSMContext):
    await callback_query.message.answer("üí≥ –ü–æ–∫—É–ø–∞—é –¥–æ–º–µ–Ω—ã...")

    file_path = os.path.join(UPLOAD_DIR, "available_domains.txt")
    if not os.path.exists(file_path):
        await callback_query.message.answer("‚ùå –§–∞–π–ª —Å –¥–æ–º–µ–Ω–∞–º–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        return

    with open(file_path, "r") as file:
        domains = [line.strip() for line in file if line.strip()]

    if not domains:
        await callback_query.message.answer("‚ùå –ù–µ—Ç –¥–æ–º–µ–Ω–æ–≤ –¥–ª—è –ø–æ–∫—É–ø–∫–∏.")
        return

    async with aiohttp.ClientSession() as session:
        purchased = await purchase_domains(domains, session)

    if purchased:
        with open(OUTPUT_FILE, "w") as file:
            file.writelines(f"{domain}\n" for domain in purchased)
        file = FSInputFile(OUTPUT_FILE)
        await callback_query.message.answer_document(file, caption="‚úÖ –ö—É–ø–ª–µ–Ω–Ω—ã–µ –¥–æ–º–µ–Ω—ã —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã.")
    else:
        await callback_query.message.answer("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∫—É–ø–∏—Ç—å –¥–æ–º–µ–Ω—ã.")

    await state.clear()


# üïπÔ∏è –û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞–∂–∞—Ç–∏—è –∫–Ω–æ–ø–∫–∏ "–ù–µ—Ç" ‚Üí –ñ–¥–µ–º –Ω–æ–≤—ã–π —Ñ–∞–π–ª
@router.callback_query(F.data == "no_dynadot_pay")
async def handle_no_dynadot_pay(callback_query: CallbackQuery, state: FSMContext):
    await callback_query.message.answer("üìÇ –ó–∞–≥—Ä—É–∑–∏—Ç–µ –Ω–æ–≤—ã–π —Ñ–∞–π–ª —Å –¥–æ–º–µ–Ω–∞–º–∏.")
    await state.set_state(DomainStates.WaitingForFile)


# üì• –ó–∞–≥—Ä—É–∑–∫–∞ –∏ –æ–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–æ–≤–æ–≥–æ —Ñ–∞–π–ª–∞
@router.message(DomainStates.WaitingForFile, F.document)
async def handle_file_upload(message: Message, state: FSMContext):
    file_name = message.document.file_name

    if not file_name.endswith(".txt"):
        await message.answer("‚ùå –ù—É–∂–Ω–æ –∑–∞–≥—Ä—É–∑–∏—Ç—å .txt —Ñ–∞–π–ª.")
        return

    file_path = os.path.join(UPLOAD_DIR, file_name)
    await message.bot.download(message.document.file_id, file_path)

    await message.answer("‚è≥ –û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é —Ñ–∞–π–ª...")

    with open(file_path, "r") as file:
        domains = [line.strip() for line in file if line.strip()]

    if domains:
        buttons = [
            [InlineKeyboardButton(text="–î–∞", callback_data="yes_dynadot_pay")],
            [InlineKeyboardButton(text="–ù–µ—Ç", callback_data="no_dynadot_pay")],
        ]
        keyboard = InlineKeyboardMarkup(inline_keyboard=buttons)
        await message.answer(
            "‚úÖ –§–∞–π–ª –∑–∞–≥—Ä—É–∂–µ–Ω. –•–æ—Ç–∏—Ç–µ —Å—Ä–∞–∑—É –∫—É–ø–∏—Ç—å –¥–æ–º–µ–Ω—ã?", reply_markup=keyboard
        )
        await state.set_state(DomainStates.WaitingForConfirmation)
    else:
        await message.answer("‚ùå –§–∞–π–ª –ø—É—Å—Ç –∏–ª–∏ —Å–æ–¥–µ—Ä–∂–∏—Ç –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ.")
        await state.clear()
